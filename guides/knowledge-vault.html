<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>knowledge-vault</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="knowledge-vault_files/libs/clipboard/clipboard.min.js"></script>
<script src="knowledge-vault_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="knowledge-vault_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="knowledge-vault_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="knowledge-vault_files/libs/quarto-html/popper.min.js"></script>
<script src="knowledge-vault_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="knowledge-vault_files/libs/quarto-html/anchor.min.js"></script>
<link href="knowledge-vault_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="knowledge-vault_files/libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="knowledge-vault_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="knowledge-vault_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="knowledge-vault_files/libs/bootstrap/bootstrap-d6b7f60ecdfcbdf4dbbfa24131ac600f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="knowledge-vault-ontology-driven-notes-with-claude-code" class="level1">
<h1>Knowledge Vault: Ontology-Driven Notes with Claude Code</h1>
<p>A methodology for building a linked knowledge base using Claude Code as the agent that creates, connects, and maintains notes. The vault is a folder of markdown files with explicit rules that teach Claude how to navigate and operate it — the same pattern used for codebases, applied to knowledge.</p>
<hr>
<section id="who-this-is-for" class="level2">
<h2 class="anchored" data-anchor-id="who-this-is-for">Who This Is For</h2>
<p>You want a “second brain” or knowledge management system, but: - You already use Claude Code and don’t want a separate tool - You want the AI to actively find connections, not just store text - You care about note quality over note quantity - You want explicit rules governing how the AI operates on your notes</p>
<p>This guide shows how to scaffold a knowledge vault using Claude Code’s configuration layers (CLAUDE.md, <code>.claude/rules/</code>) as the control system.</p>
<hr>
</section>
<section id="the-core-insight" class="level2">
<h2 class="anchored" data-anchor-id="the-core-insight">1. The Core Insight</h2>
<p>A codebase is a folder of text files connected by imports and references. A knowledge vault is a folder of text files connected by links and topic pages. The structural similarity means the same tools and navigation patterns work for both.</p>
<p>Claude Code already knows how to: - Read an index (CLAUDE.md) and orient via directory structure - Follow references between files - Create new files that link to existing ones - Maintain consistency across a project</p>
<p>A knowledge vault is the same operation with different content. The addition is explicit rules about navigation, note quality, and connection discovery.</p>
<hr>
</section>
<section id="vault-structure" class="level2">
<h2 class="anchored" data-anchor-id="vault-structure">2. Vault Structure</h2>
<pre><code>vault/
├── 00_inbox/                  # Capture zone — zero friction
├── 01_thinking/               # Active development
│   ├── topic-page.md          # Maps of Content (MOCs)
│   └── notes/                 # Individual developing notes
├── 02_reference/              # External knowledge
│   ├── tools/                 # Tool documentation
│   ├── approaches/            # Methods and patterns
│   └── sources/               # Summaries of external works
├── 03_creating/               # Drafts in progress
│   └── drafts/
├── 04_published/              # Finished work archive
├── 05_archive/                # Inactive content
├── 06_system/                 # Templates and scripts
│   └── templates/
│       └── note-template.md
├── CLAUDE.md                  # Slim routing file
├── .claude/
│   └── rules/                 # Auto-loaded rule files
│       ├── ontology-schema.md
│       ├── knowledge-constraints.md
│       ├── authority-scoring.md
│       ├── vault-operations.md
│       └── note-conventions.md
├── index.md                   # Master inventory
└── .gitignore</code></pre>
<section id="folder-semantics" class="level3">
<h3 class="anchored" data-anchor-id="folder-semantics">Folder Semantics</h3>
<p>Folders encode status. Moving a note between folders changes its lifecycle stage:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 27%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th>Folder</th>
<th>Status</th>
<th>Entry Point</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>00_inbox/</code></td>
<td>Raw capture, unprocessed</td>
<td>“Capture this”</td>
</tr>
<tr class="even">
<td><code>01_thinking/</code></td>
<td>Active development, topic pages</td>
<td>“Develop this” / “Connect this”</td>
</tr>
<tr class="odd">
<td><code>02_reference/</code></td>
<td>External knowledge summaries</td>
<td>“Reference this source”</td>
</tr>
<tr class="even">
<td><code>03_creating/</code></td>
<td>Drafting toward output</td>
<td>“Write this up”</td>
</tr>
<tr class="odd">
<td><code>04_published/</code></td>
<td>Finished, stable</td>
<td>User confirms</td>
</tr>
<tr class="even">
<td><code>05_archive/</code></td>
<td>Inactive</td>
<td>User confirms</td>
</tr>
<tr class="odd">
<td><code>06_system/</code></td>
<td>Templates, scripts</td>
<td>Infrastructure</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="three-operating-modes" class="level2">
<h2 class="anchored" data-anchor-id="three-operating-modes">3. Three Operating Modes</h2>
<p>The CLAUDE.md defines three modes that Claude selects based on user intent:</p>
<section id="capture-mode" class="level3">
<h3 class="anchored" data-anchor-id="capture-mode">Capture Mode</h3>
<p>Quick deposits into <code>00_inbox/</code>. Zero friction. No orientation, no connection search, no index update. Triggered by “capture,” “jot down,” “quick note.”</p>
</section>
<section id="synthesis-mode" class="level3">
<h3 class="anchored" data-anchor-id="synthesis-mode">Synthesis Mode</h3>
<p>Linking, connecting, developing. Triggered by “connect,” “develop,” “link,” “find connections.” Claude must: 1. Orient: read <code>index.md</code> + relevant topic pages 2. Search for related content 3. Add links woven into prose 4. Update topic pages and index</p>
</section>
<section id="creation-mode" class="level3">
<h3 class="anchored" data-anchor-id="creation-mode">Creation Mode</h3>
<p>Building output documents from vault notes. Triggered by “draft,” “write up.” Claude reads source notes, creates in <code>03_creating/drafts/</code>, tracks provenance.</p>
<hr>
</section>
</section>
<section id="the-rules-system" class="level2">
<h2 class="anchored" data-anchor-id="the-rules-system">4. The Rules System</h2>
<p>Five rules files in <code>.claude/rules/</code> teach Claude how to operate the vault. These are auto-loaded every session.</p>
<section id="ontology-schema.md-what-exists" class="level3">
<h3 class="anchored" data-anchor-id="ontology-schema.md-what-exists"><code>ontology-schema.md</code> — What exists</h3>
<p>Defines the node types (Note, Claim, Source, TopicPage, Question, Insight, Method) and edge types (supports, refutes, extends, contextualizes, etc.). Adapted from the <a href="claude-code-architecture-review.md">architecture review methodology</a>.</p>
<p>Key invariant: every Note links to at least one TopicPage.</p>
</section>
<section id="knowledge-constraints.md-quality-rules" class="level3">
<h3 class="anchored" data-anchor-id="knowledge-constraints.md-quality-rules"><code>knowledge-constraints.md</code> — Quality rules</h3>
<ul>
<li><strong>Composability:</strong> Notes must stand alone (no prerequisite reading)</li>
<li><strong>Naming:</strong> Notes named as claims (“batch correction requires benchmarking”) not topics (“batch correction”)</li>
<li><strong>Linking:</strong> Links woven into prose with articulated relationships, not footnote lists</li>
<li><strong>Depth over breadth:</strong> Fewer developed notes beat many stubs</li>
</ul>
</section>
<section id="authority-scoring.md-source-quality" class="level3">
<h3 class="anchored" data-anchor-id="authority-scoring.md-source-quality"><code>authority-scoring.md</code> — Source quality</h3>
<p>Deterministic formula for scoring external sources. Same pattern as the architecture review guide: LLM proposes inputs (source type, domain, recency, venue), formula computes the score. LLM may not assign scores directly.</p>
</section>
<section id="vault-operations.md-how-claude-navigates" class="level3">
<h3 class="anchored" data-anchor-id="vault-operations.md-how-claude-navigates"><code>vault-operations.md</code> — How Claude navigates</h3>
<ul>
<li><strong>Orientation protocol:</strong> Read index → identify topic pages → read them → then act</li>
<li><strong>Connection search:</strong> Every new note triggers grep for related content</li>
<li><strong>Breadcrumbs:</strong> After working in a topic area, log activity in the topic page</li>
<li><strong>Index maintenance:</strong> Update <code>index.md</code> after every create/move/archive</li>
</ul>
</section>
<section id="note-conventions.md-format-rules" class="level3">
<h3 class="anchored" data-anchor-id="note-conventions.md-format-rules"><code>note-conventions.md</code> — Format rules</h3>
<ul>
<li>YAML frontmatter with title, date, status, topics</li>
<li>Status lifecycle: inbox → developing → mature → published → archived</li>
<li>Bidirectional linking: if A links to B, B acknowledges A</li>
<li>Topic pages are maps (they link and describe), not containers</li>
</ul>
<hr>
</section>
</section>
<section id="topic-pages-maps-of-content" class="level2">
<h2 class="anchored" data-anchor-id="topic-pages-maps-of-content">5. Topic Pages (Maps of Content)</h2>
<p>Topic pages live in <code>01_thinking/</code> and serve as navigation hubs. They describe a topic area’s landscape, link to relevant notes, track open questions, and record breadcrumbs of recent activity.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Research Methods</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>Clinical research methodology, statistical approaches, and reproducibility.</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">## Core Notes</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Claim-form title</span><span class="co">](notes/filename.md)</span> — one-line relationship description</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="fu">## Open Questions</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Unanswered question driving inquiry in this area</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## Recent Activity</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**2026-02-13:** Created <span class="co">[</span><span class="ot">note title</span><span class="co">](path)</span>. Connected to <span class="co">[</span><span class="ot">other note</span><span class="co">](path)</span>.</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Topic pages are named as topics (not claims) because they’re maps, not assertions.</p>
<hr>
</section>
<section id="the-llm-boundary" class="level2">
<h2 class="anchored" data-anchor-id="the-llm-boundary">6. The LLM Boundary</h2>
<p>The CLAUDE.md defines explicit boundaries:</p>
<p><strong>Claude MAY:</strong> Create/link/move notes, propose connections, update index and topic pages, suggest status transitions (inbox → thinking).</p>
<p><strong>Claude MUST NOT:</strong> Delete notes without confirmation, assign authority scores directly, skip orientation before modifying a topic area, move notes to published/archive without confirmation.</p>
<p><strong>Claude MUST:</strong> Orient before acting, record breadcrumbs, search for connections after creating notes, update index after changes.</p>
<hr>
</section>
<section id="bootstrapping" class="level2">
<h2 class="anchored" data-anchor-id="bootstrapping">7. Bootstrapping</h2>
<p>To scaffold a vault:</p>
<ol type="1">
<li>Use the <a href="../skills/knowledge-vault-skill.md">Knowledge Vault Skill</a> — it generates the full directory structure, CLAUDE.md, rules files, templates, index, and starter topic pages</li>
<li>Or follow the structure in Section 2 and adapt the rules to your domain</li>
</ol>
<p>The skill produces a working vault that Claude can operate immediately. Start by capturing a few notes, then use synthesis mode to develop connections.</p>
<hr>
</section>
<section id="relationship-to-other-patterns" class="level2">
<h2 class="anchored" data-anchor-id="relationship-to-other-patterns">8. Relationship to Other Patterns</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Pattern</th>
<th>Where</th>
<th>How It Relates</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="claude-code-architecture-review.md">Architecture Review</a></td>
<td>Generic methodology</td>
<td>The vault is one application of the ontology scaffolding pattern</td>
</tr>
<tr class="even">
<td><a href="quarto-ontology-website.md">Quarto Ontology Website</a></td>
<td>Website builder</td>
<td>Another application — typed pages with metadata relationships</td>
</tr>
<tr class="odd">
<td><a href="claude-code-setup.md">Claude Code Setup</a></td>
<td>Configuration guide</td>
<td>How to set up the CLAUDE.md and rules layer that the vault uses</td>
</tr>
</tbody>
</table>
<p>The vault pattern demonstrates the architecture review methodology in a domain (knowledge management) that anyone can adopt without domain-specific data.</p>
<hr>
</section>
<section id="when-to-use-this-vs.-other-tools" class="level2">
<h2 class="anchored" data-anchor-id="when-to-use-this-vs.-other-tools">9. When to Use This vs.&nbsp;Other Tools</h2>
<p><strong>Use the vault when:</strong> - You already work in Claude Code and want integrated knowledge management - You want the AI to actively maintain and connect your notes - You value explicit rules over implicit conventions - Your knowledge base is primarily text (not images, databases, or structured data)</p>
<p><strong>Consider alternatives when:</strong> - You need collaborative editing (Notion, Confluence) - You need graph visualization (Obsidian, Logseq) - You need structured data management (databases, spreadsheets) - You want zero configuration (plain notes in a folder)</p>
<p>The vault is opinionated by design. The rules system is the value — it prevents note sprawl, enforces quality, and teaches the AI how to be a useful knowledge partner rather than just a file creator.</p>
<hr>
</section>
<section id="future-directions-formal-graph-methods" class="level2">
<h2 class="anchored" data-anchor-id="future-directions-formal-graph-methods">10. Future Directions: Formal Graph Methods</h2>
<p>The convention-based vault (Sections 1-9) is Phase 1: links are markdown references, structure is implicit in prose, and the LLM agent traverses the graph by reading files. This works well for hundreds of notes and is immediately operational with no infrastructure.</p>
<p>But the vault’s link structure is a <strong>directed graph</strong> — and graphs have a rich mathematical theory. As a vault grows, formalizing the graph opens up operations that convention-based linking cannot support.</p>
<section id="the-adjacency-matrix" class="level3">
<h3 class="anchored" data-anchor-id="the-adjacency-matrix">The adjacency matrix</h3>
<p>Every vault is implicitly a directed acyclic graph (DAG) where nodes are notes and edges are links. This graph has an <strong>adjacency matrix</strong> <code>A</code> where <code>A[i,j] = 1</code> if note <code>i</code> links to note <code>j</code>:</p>
<pre><code>         note_1  note_2  note_3  note_4
note_1  [  0       1       0       1  ]
note_2  [  0       0       1       0  ]
note_3  [  0       0       0       1  ]
note_4  [  0       0       0       0  ]</code></pre>
<p>Weighted variants encode edge type or connection strength instead of binary 0/1. The ontology’s edge types (<code>supports</code>, <code>refutes</code>, <code>extends</code>, etc.) become different weight channels or separate adjacency matrices per relation.</p>
</section>
<section id="what-matrix-operations-give-you" class="level3">
<h3 class="anchored" data-anchor-id="what-matrix-operations-give-you">What matrix operations give you</h3>
<p>Once the graph is a matrix, linear algebra answers structural questions that are expensive or impossible to answer by reading files:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 31%">
<col style="width: 54%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>What it tells you</th>
<th>How</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Reachability</strong></td>
<td>Can note A reach note B through any chain of links?</td>
<td><code>(I + A)^n</code> — the transitive closure. Non-zero entry means reachable.</td>
</tr>
<tr class="even">
<td><strong>Path length</strong></td>
<td>How many hops between two concepts?</td>
<td><code>A^k</code> — entry <code>(i,j)</code> counts paths of exactly length <code>k</code> between <code>i</code> and <code>j</code>.</td>
</tr>
<tr class="odd">
<td><strong>Centrality</strong></td>
<td>Which notes are structurally most important?</td>
<td>Eigenvector centrality (dominant eigenvector of <code>A</code>). A note is important if important notes link to it — the same idea as PageRank.</td>
</tr>
<tr class="even">
<td><strong>Clustering</strong></td>
<td>What topic communities emerge from link structure (not your subjective grouping)?</td>
<td>Spectral clustering on the graph Laplacian <code>L = D - A</code>. The eigenvectors of <code>L</code> with smallest non-zero eigenvalues reveal natural clusters.</td>
</tr>
<tr class="odd">
<td><strong>Latent structure</strong></td>
<td>What hidden dimensions organize the vault?</td>
<td>SVD of the adjacency or incidence matrix. Low-rank approximation reveals latent topics that may not correspond to your explicit topic pages.</td>
</tr>
<tr class="even">
<td><strong>Similarity</strong></td>
<td>Which notes are structurally similar (linked to similar neighborhoods)?</td>
<td>Cosine similarity of rows in <code>A</code> or in a graph embedding space.</td>
</tr>
</tbody>
</table>
</section>
<section id="from-convention-to-computation" class="level3">
<h3 class="anchored" data-anchor-id="from-convention-to-computation">From convention to computation</h3>
<p>The progression looks like:</p>
<pre><code>Phase 1: Convention-based (this guide)
  - Links are markdown references in prose
  - LLM traverses by reading files
  - Structure is implicit, maintained by rules
  - Tools: Claude Code, grep, file system

Phase 2: Extracted graph
  - Parse vault links into an adjacency matrix
  - Compute centrality, clusters, reachability
  - Use results to guide the LLM ("these notes are structurally central,
    these clusters exist, these notes are isolated")
  - Tools: NetworkX, igraph, numpy

Phase 3: Graph embeddings
  - Embed nodes into a vector space (node2vec, TransE, or GNN-based)
  - Cosine similarity finds related concepts the link structure implies
    but that aren't explicitly linked yet
  - Combine with text embeddings (from the note content) for hybrid
    structure + semantic similarity
  - Tools: PyTorch Geometric, DGL, sentence-transformers

Phase 4: Algebraic knowledge representation
  - Represent the full typed ontology (node types, edge types, constraints)
    as a tensor algebra — adjacency tensors per relation type
  - Compositional reasoning: "find notes that `support` a claim that
    `extends` a note in cluster C" becomes a tensor contraction
  - Constraint satisfaction as linear programs over the graph
  - Tools: Custom, building on sparse tensor libraries</code></pre>
</section>
<section id="practical-entry-point" class="level3">
<h3 class="anchored" data-anchor-id="practical-entry-point">Practical entry point</h3>
<p>Phase 2 is accessible today with a small script:</p>
<ol type="1">
<li>Parse <code>index.md</code> and all vault <code>.md</code> files to extract links</li>
<li>Build an adjacency matrix (scipy sparse or numpy)</li>
<li>Compute eigenvector centrality, spectral clusters, and reachability</li>
<li>Output a report: “Your vault has N notes, M links. The 5 most central notes are … The natural clusters are … These 3 notes are isolated.”</li>
<li>Feed that report to Claude as context for synthesis operations</li>
</ol>
<p>This gives the LLM structural awareness it cannot get from reading files sequentially. It knows which notes are hubs, which are orphans, and which clusters exist — without reading every note first.</p>
</section>
<section id="the-deeper-idea" class="level3">
<h3 class="anchored" data-anchor-id="the-deeper-idea">The deeper idea</h3>
<p>A knowledge vault’s link structure IS a mathematical object. The convention- based approach (Phase 1) works because the graph is small enough for a sequential reader to hold in context. But graphs have properties that sequential reading cannot efficiently discover:</p>
<ul>
<li><strong>Transitivity:</strong> If A supports B and B supports C, does A transitively support C? Matrix powers answer this instantly.</li>
<li><strong>Community structure:</strong> Which concepts cluster together by link pattern, independent of your folder organization? The Laplacian’s spectrum reveals this.</li>
<li><strong>Importance:</strong> Which notes would, if removed, most fragment the graph? Betweenness centrality answers this.</li>
<li><strong>Latent dimensions:</strong> What hidden axes organize your thinking that you haven’t made explicit? SVD of the adjacency matrix reveals these.</li>
</ul>
<p>The vault’s convention-based rules (orientation protocol, connection search, breadcrumbs) are heuristic approximations of these graph operations. The formal methods don’t replace the conventions — they augment them with structural awareness that scales beyond what sequential reading can provide.</p>
</section>
<section id="tooling-landscape" class="level3">
<h3 class="anchored" data-anchor-id="tooling-landscape">Tooling landscape</h3>
<p>The choice of language depends on the role: exploratory analysis (developing the math), integrated agent (Claude Code calls it), or production tool (ships as a binary).</p>
<section id="python-the-default-for-integration" class="level4">
<h4 class="anchored" data-anchor-id="python-the-default-for-integration">Python — the default for integration</h4>
<p>Python is the natural choice for Phases 2-3 because Claude Code can run scripts directly and parse the output. The ecosystem covers the full stack:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 33%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>Phase</th>
<th>Packages</th>
<th>What they do</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2: Extracted graph</td>
<td><code>networkx</code>, <code>igraph</code></td>
<td>Graph construction, centrality, community detection</td>
</tr>
<tr class="even">
<td>2: Linear algebra</td>
<td><code>scipy.sparse</code>, <code>numpy</code></td>
<td>Adjacency matrices, eigendecomposition, matrix powers</td>
</tr>
<tr class="odd">
<td>2: Clustering</td>
<td><code>scikit-learn</code></td>
<td>Spectral clustering, k-means on embeddings</td>
</tr>
<tr class="even">
<td>2: Visualization</td>
<td><code>matplotlib</code>, <code>pyvis</code></td>
<td>Static and interactive graph plots</td>
</tr>
<tr class="odd">
<td>3: Graph embeddings</td>
<td><code>PyTorch Geometric</code>, <code>DGL</code></td>
<td>GNN-based node embeddings</td>
</tr>
<tr class="even">
<td>3: Node embeddings</td>
<td><code>node2vec</code>, <code>gensim</code></td>
<td>Random-walk-based node embeddings</td>
</tr>
<tr class="odd">
<td>3: Hybrid</td>
<td><code>sentence-transformers</code></td>
<td>Text embeddings to combine with structure embeddings</td>
</tr>
</tbody>
</table>
<p>A Phase 2 pipeline is ~100 lines: parse markdown links, build a NetworkX graph, compute <code>nx.eigenvector_centrality()</code>, <code>nx.community.louvain_communities()</code>, and <code>nx.has_path()</code>, then output a report.</p>
</section>
<section id="r-tidy-graph-analysis-alongside-research-code" class="level4">
<h4 class="anchored" data-anchor-id="r-tidy-graph-analysis-alongside-research-code">R — tidy graph analysis alongside research code</h4>
<p>R is strong for Phase 2, especially if the vault analysis lives alongside tidymodels research workflows. The tidyverse-native graph ecosystem is well-designed:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 40%">
<col style="width: 59%">
</colgroup>
<thead>
<tr class="header">
<th>Package</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>tidygraph</code></td>
<td>Tidy verbs for graph manipulation — <code>mutate()</code>, <code>filter()</code>, <code>arrange()</code> on nodes and edges. Wraps igraph with a tibble interface.</td>
</tr>
<tr class="even">
<td><code>ggraph</code></td>
<td>Grammar-of-graphics for networks. Publication-quality graph visualizations with the same API as ggplot2.</td>
</tr>
<tr class="odd">
<td><code>igraph</code></td>
<td>The workhorse — centrality, community detection, shortest paths, spectral methods. Underneath tidygraph.</td>
</tr>
<tr class="even">
<td><code>Matrix</code></td>
<td>Sparse matrix classes and linear algebra. Efficient adjacency matrices for large vaults.</td>
</tr>
</tbody>
</table>
<p>R is weaker for Phase 3 (graph neural networks, deep embeddings) — the ecosystem for this lives in Python. But for Phase 2 analysis with beautiful visualizations, tidygraph + ggraph is arguably better than the Python equivalent.</p>
</section>
<section id="julia-performance-for-large-vaults" class="level4">
<h4 class="anchored" data-anchor-id="julia-performance-for-large-vaults">Julia — performance for large vaults</h4>
<p>Julia’s value appears at scale (thousands of notes, large embedding spaces) and in Phase 3-4 where sparse tensor operations dominate:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 40%">
<col style="width: 59%">
</colgroup>
<thead>
<tr class="header">
<th>Package</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Graphs.jl</code></td>
<td>Graph algorithms, equivalent to NetworkX/igraph</td>
</tr>
<tr class="even">
<td><code>SparseArrays</code> (stdlib)</td>
<td>Sparse matrix operations, near-C performance</td>
</tr>
<tr class="odd">
<td><code>Arpack.jl</code></td>
<td>Large-scale eigenvalue problems (for spectral methods on big graphs)</td>
</tr>
<tr class="even">
<td><code>GraphNeuralNetworks.jl</code></td>
<td>GNN layers, graph convolutions</td>
</tr>
</tbody>
</table>
<p>Julia’s type system also maps naturally to ontology node types — you can define <code>Note</code>, <code>Claim</code>, <code>Source</code> as Julia types and dispatch graph operations on them. This matters in Phase 4 where the typed ontology becomes a typed algebra.</p>
<p>The tradeoff is ecosystem size (fewer packages, smaller community) and startup latency (first-run compilation). Worth it when Python’s speed becomes the bottleneck.</p>
</section>
<section id="rust-production-cli-tool" class="level4">
<h4 class="anchored" data-anchor-id="rust-production-cli-tool">Rust — production CLI tool</h4>
<p>Rust is the wrong tool for exploration but the right tool for a finished product. Once the math is settled, a <code>vault-graph</code> CLI built with <code>petgraph</code> could:</p>
<ul>
<li>Parse all vault markdown files and extract links</li>
<li>Build the adjacency matrix in memory</li>
<li>Compute centrality, clusters, reachability</li>
<li>Output a JSON report that Claude Code reads as context</li>
</ul>
<p>This ships as a single binary, runs in milliseconds, and needs no runtime. It’s the Phase 2 pipeline hardened for daily use — a tool Claude Code calls before every synthesis operation.</p>
</section>
<section id="mathematica-wolfram-language-develop-the-math" class="level4">
<h4 class="anchored" data-anchor-id="mathematica-wolfram-language-develop-the-math">Mathematica / Wolfram Language — develop the math</h4>
<p>Mathematica is exceptional for the <em>exploratory</em> phase where you’re figuring out which graph operations are informative:</p>
<ul>
<li><code>Graph[]</code>, <code>AdjacencyMatrix[]</code>, <code>CommunityStructure[]</code>, <code>EigenvectorCentrality[]</code> are first-class language primitives</li>
<li>Symbolic computation lets you express the ontology algebra formally — define composition rules for edge types, derive properties symbolically before evaluating numerically</li>
<li>The notebook environment supports rapid iteration with inline visualization</li>
</ul>
<p>But Mathematica is a poor <em>agent</em>. It’s proprietary, expensive, and hard to integrate as a CLI tool. The workflow is: develop and prove operations in Mathematica, then implement the production version in Python/Julia/Rust.</p>
<p>The free Wolfram Engine (developer license) can be scripted from the command line via <code>wolframscript</code>, which partially addresses the integration gap — but the license terms and startup overhead make it impractical as a sub-agent that Claude Code calls on every vault operation.</p>
</section>
</section>
<section id="integration-mcp-server-as-the-bridge" class="level3">
<h3 class="anchored" data-anchor-id="integration-mcp-server-as-the-bridge">Integration: MCP server as the bridge</h3>
<p>The cleanest integration path is an <strong>MCP server</strong> that exposes graph operations as tools Claude Code can call natively:</p>
<pre><code>Claude Code                    MCP Server (Python/Rust)
    │                               │
    ├── analyze_vault_graph() ──────►  Parse .md files
    │                               │  Build adjacency matrix
    │                               │  Compute centrality, clusters
    │◄── {centrality: [...],  ──────┤  Return structured report
    │     clusters: [...],          │
    │     isolated: [...]}          │
    │                               │
    ├── find_similar(note_id) ──────►  Cosine similarity in
    │                               │  embedding space
    │◄── [related_notes...] ────────┤</code></pre>
<p>With an MCP server, <code>analyze_vault_graph</code> becomes a tool as natural as <code>search_preprints</code> or <code>compound_search</code>. Claude’s orientation protocol could call it automatically: read <code>index.md</code>, call the graph analysis tool, then operate with structural awareness.</p>
<p>The server can be built in: - <strong>Python</strong> (simplest, use <code>networkx</code> + the MCP SDK) - <strong>TypeScript</strong> (if you want the MCP SDK’s native language) - <strong>Rust</strong> (fastest, use <code>petgraph</code>, expose via MCP protocol)</p>
<p>This separates concerns cleanly: the graph engine handles the math, the LLM handles the reasoning, and the MCP protocol handles the interface.</p>
</section>
<section id="recommended-progression" class="level3">
<h3 class="anchored" data-anchor-id="recommended-progression">Recommended progression</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 37%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th>When</th>
<th>What</th>
<th>Language</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Now</td>
<td>Phase 1 convention-based vault</td>
<td>Markdown + Claude Code</td>
<td>No infrastructure needed</td>
</tr>
<tr class="even">
<td>50+ notes</td>
<td>Phase 2 graph analysis script</td>
<td>Python or R</td>
<td>Quick to build, informative results</td>
</tr>
<tr class="odd">
<td>200+ notes</td>
<td>Phase 2 as MCP server</td>
<td>Python or Rust</td>
<td>Integrates into Claude Code natively</td>
</tr>
<tr class="even">
<td>Scaling</td>
<td>Phase 3 graph + text embeddings</td>
<td>Python (PyTorch Geometric + sentence-transformers)</td>
<td>Finds connections the link structure implies but hasn’t made explicit</td>
</tr>
<tr class="odd">
<td>Research</td>
<td>Phase 4 algebraic formalization</td>
<td>Julia or Mathematica → Julia</td>
<td>Performance on tensor operations, type system for ontology</td>
</tr>
</tbody>
</table>
<p>Start with convention-based linking (this guide). Add graph analysis when the vault is large enough that sequential reading misses structural patterns. The formal methods don’t replace the conventions — they augment them.</p>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<ul>
<li>Newman, M. E. J. (2010). <em>Networks: An Introduction</em>. Oxford University Press. — The standard reference for graph theory applied to real networks.</li>
<li>Grover &amp; Leskovec (2016). “node2vec: Scalable Feature Learning for Networks.” — Graph embedding method that maps nodes to vectors preserving neighborhood structure.</li>
<li>Bordes et al.&nbsp;(2013). “Translating Embeddings for Modeling Multi-relational Data.” — TransE: knowledge graph embeddings where relations are translations in vector space.</li>
<li>Chung, F. R. K. (1997). <em>Spectral Graph Theory</em>. AMS. — Mathematical foundations for using eigenvalues of graph matrices.</li>
<li>Hamilton, W. L. (2020). <em>Graph Representation Learning</em>. Morgan &amp; Claypool. — Modern survey of graph neural networks and embedding methods.</li>
<li>Csardi &amp; Nepusz (2006). “The igraph software package for complex network research.” — The igraph library, used by both R and Python for graph algorithms.</li>
<li>Pedersen, T. L. (2024). <em>tidygraph</em> and <em>ggraph</em> R packages. — Tidy interface for graph manipulation and grammar-of-graphics visualization.</li>
</ul>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>